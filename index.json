[{"content":"\n\n### 关于AOP的个人理解 \n\nAOP联盟定义的AOP体系结构把与AOP相关的概念大致分为了由高到低、从使用到实现的三个层次。关于这个体系结构，个人的理解是这样的，从上往下，最高层是语言和开发环境，在这个环境中可以看到几个重要的概念：base可以视为待增强对象，或者说目标对象；aspect指切面，通常包含对于base的增强应用；configuration可以看成是一种编织或者说配置，通过在AOP体系中提供这个configuration配置环境，可以把base和aspect结合起来，从而完成切面对目标对象的编织实现。 \n\n对Spring平台或者说生态系统来说，AOP是Spring框架的核心功能模块之一。AOP与IOC容器的结合使用, 为应用开发或者Spring自身功能的扩展都提供了许多便利。Spring AOP的实现和其他特性的实现一样，非常丰富，除了可以使用Spring本身提供的AOP实现之外，还封装了业界优秀的AOP解决方案AspectJ来让应用使用。在这里，主要对Spring自身的AOP实现原理做一些解析；在这个AOP实现中，Spring充分利用了IOC容器Proxy代理对象以及AOP拦截器的功能特性，通过这些对AOP基本功能的封装机制，为用户提供了AOP的实现框架。所以，要了解这些AOP的基本实现，需要我们对Java 的Proxy机制有一些基本了解。 \n\n### AOP实现的基本线索 \n\nAOP实现中，可以看到三个主要的步骤，一个是代理对象的生成，然后是拦截器的作用，然后是Aspect编织的实现。AOP框架的丰富，很大程度体现在这三个具体实现中，所具有的丰富的技术选择，以及如何实现与IOC容器的无缝结合。毕竟这也是一个非常核心的模块，需要满足不同的应用需求带来的解决方案需求。 \n在Spring AOP的实现原理中，我们主要举ProxyFactoryBean的实现作为例子和实现的基本线索进行分析；很大一个原因，是因为ProxyFactoryBean是在Spring IoC环境中，创建AOP应用的最底层方法，从中，可以看到一条实现AOP的基本线索。在ProxyFactoryBean中，它的AOP实现需要依赖JDK或者CGLIB提供的Proxy特性。从FactoryBean中获取对象，是从getObject()方法作为入口完成的。然后为proxy代理对象配置advisor链，这个配置是在initializeAdvisorChain方法中完成的；然后就为生成AOP代理对象做好了准备，生成代理对象如下所示： \n\n```java\n\tprivate synchronized Object getSingletonInstance() {\n\t\tif (this.singletonInstance == null) {\n\t\t\tthis.targetSource = freshTargetSource();\n\t\t\tif (this.autodetectInterfaces \u0026\u0026 getProxiedInterfaces().length == 0 \u0026\u0026 !isProxyTargetClass()) {\n\t\t\t\t// Rely on AOP infrastructure to tell us what interfaces to proxy.\n\t\t\t\tClass targetClass = getTargetClass();\n\t\t\t\tif (targetClass == null) {\n\t\t\t\t\tthrow new FactoryBeanNotInitializedException(\"Cannot determine target class for proxy\");\n\t\t\t\t}\n\t // 这里设置代理对象的接口\t\tsetInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));\n\t\t\t}\n\t\t\t// Initialize the shared singleton instance.\n\t\t\tsuper.setFrozen(this.freezeProxy);\n\t\t\t// 注意这里的方法会使用ProxyFactory来生成我们需要的Proxy\n\t\t\tthis.singletonInstance = getProxy(createAopProxy());\n\t\t}\n\t\treturn this.singletonInstance;\n\t}\n\t//使用createAopProxy返回的AopProxy来得到代理对象\n\tprotected Object getProxy(AopProxy aopProxy) {\n\t\treturn aopProxy.getProxy(this.proxyClassLoader);\n\t}\n```\n\n上面我们看到了在Spring中通过ProxyFactoryBean实现AOP功能的第一步，得到AopProxy代理对象的基本过程，下面我们看看AopProxy代理对象的拦截机制是怎样发挥作用，是怎样实现AOP功能的。我们知道，对代理对象的生成，有CGLIB和JDK两种生成方式，在CGLIB中，对拦截器设计是通过在Cglib2AopProxy的AopProxy代理对象生成的时候，在回调DynamicAdvisedInterceptor对象中实现的，这个回调的实现在intercept方法中完成。对于AOP是怎样完成对目标对象的增强的，这些实现是封装在AOP拦截器链中，由一个个具体的拦截器来完成的。具体拦截器的运行是在以下的代码实现中完成的，这些调用在ReflectiveMethodInvocation中。 \n\n```java\n\tpublic Object proceed() throws Throwable {\n\t\t//\tWe start with an index of -1 and increment early.\n\t\t//如果拦截器链中的拦截器迭代调用完毕，这里开始调用target的函数，这个函数是通过反射机制完成的,具体实现在：AopUtils.invokeJoinpointUsingReflection方法里面。\n\t\tif (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n\t\t\treturn invokeJoinpoint();\n\t\t}\n\t\t//这里沿着定义好的 interceptorOrInterceptionAdvice链进行处理。\n\t\tObject interceptorOrInterceptionAdvice =\n\t\t    this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n\t\tif (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n\t\t\t// Evaluate dynamic method matcher here: static part will already have\n\t\t\t// been evaluated and found to match.\n\t\t\t//这里对拦截器进行动态匹配的的判断，还记得我们前面分析的pointcut吗？这里是触发进行匹配的地方，如果和定义的pointcut匹配，那么这个advice将会得到执行。\n\t\t\tInterceptorAndDynamicMethodMatcher dm =\n\t\t\t    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n\t\t\tif (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n\t\t\t\treturn dm.interceptor.invoke(this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Dynamic matching failed.\n\t\t\t\t// Skip this interceptor and invoke the next in the chain.\n\t\t\t\t// //如果不匹配，那么这个proceed会被递归调用，直到所有的拦截器都被运行过为止。\n\t\t\t\treturn proceed();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// It's an interceptor, so we just invoke it: The pointcut will have\n\t\t\t// been evaluated statically before this object was constructed.\n\t\t\t//如果是一个interceptor，直接调用这个interceptor对应的方法\n\t\t\treturn((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n\t\t}\n\t}\n\n```\n\n在调用拦截器的时候，我们接下去就可以看到对advice的通知的调用。而经过一系列的注册，适配的过程以后，拦截器在拦截的时候，会调用到预置好的一个通知适配器，设置通知拦截器，这是一系列Spring设计好为通知服务的类的一个，是最终完成通知拦截和实现的地方，非常的关键。比如，对MethodBeforeAdviceInterceptor的实现是这样的： \n\n```java\npublic class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {\n\n\tprivate MethodBeforeAdvice advice;\n\n\n\t/**\n\t * Create a new MethodBeforeAdviceInterceptor for the given advice.\n\t * @param advice the MethodBeforeAdvice to wrap\n\t */\n\tpublic MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {\n\t\tAssert.notNull(advice, \"Advice must not be null\");\n\t\tthis.advice = advice;\n\t}\n\t//这个invoke方法是拦截器的回调方法，会在代理对象的方法被调用的时候触发回调。\n\tpublic Object invoke(MethodInvocation mi) throws Throwable {\n\t\tthis.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );\n\t\treturn mi.proceed();\n\t}\n}\n```\n\n在代码中，可以看到，就是这里，会调用advice的before方法！这样就成功的完成了before通知的编织！ \n\n因为Spring AOP本身并不打算成为一个一统天下的AOP框架，秉持Spring的一贯设计理念，设想中的Spring设计目标应该是，致力于AOP框架与IOC容器的紧密集成，通过集成AOP技术为JavaEE应用开发中遇到的普遍问题提供解决方案，从而为AOP用户使用AOP技术提供最大的便利，从这个角度上为Java EE的应用开发人员服务。在没有使用第三方AOP解决方案的时候，Spring通过虚拟机的Proxy特性和CGLIB实现了AOP的基本功能，我想，如果有了Spring AOP实现原理的知识背景，再加上我们对源代码实现的认真解读，可以为我们了解其他AOP框架与IOC容器的集成原理，也打下了很好的基础，并真正了解一个AOP框架是在怎样实现的。 \n\n这还真是就是我们喜欢开源软件一个原因，有了源代码，软件就没有什么神秘的面纱了！本立而道生，多读源代码吧，或者找一本从源代码出发讲解软件实现的书来看看，就像以前我们学习操作系统，学习TCP/IP那样！一定会有长进的。 ","cover":"/images/example.png","link":"ink-blog-spring2.html","preview":"\u003cp\u003eAOP联盟定义的AOP体系结构把与AOP相关的概念大致分为了由高到低、从使用到实现的三个层次。关于这个体系结构，个人的理解是这样的，从上往下，最高层是语言和开发环境，在这个环境中可以看到几个重要的概念：base可以视为待增强对象，或者说目标对象；aspect指切面，通常包含对于base的增强应用；configuration可以看成是一种编织或者说配置，通过在AOP体系中提供这个configuration配置环境，可以把base和aspect结合起来，从而完成切面对目标对象的编织实现。\u003c/p\u003e\n","title":"Spring技术内幕——深入解析Spring架构与设计原理（二）AOP"},{"content":"\n\n### IOC的基础 \n\n下面我们从IOC/AOP开始，它们是Spring平台实现的核心部分；虽然，我们一开始大多只是在这个层面上，做一些配置和外部特性的使用工作，但对这两个核心模块工作原理和运作机制的理解，对深入理解Spring平台，却是至关重要的；因为，它们同时也是Spring其他模块实现的基础。从Spring要做到的目标，也就是从简化Java EE开发的出发点来看，简单的来说，它是通过对POJO开发的支持，来具体实现的；具体的说，Spring通过为应用开发提供基于POJO的开发模式，把应用开发和复杂的Java EE服务，实现解耦，并通过提高单元测试的覆盖率，从而有效的提高整个应用的开发质量。这样一来，实际上，就需要把为POJO提供支持的，各种Java EE服务支持抽象到应用平台中去，去封装起来；而这种封装功能的实现，在Spring中，就是由IOC容器以及AOP来具体提供的，这两个模块，在很大程度上，体现了Spring作为应用开发平台的核心价值。它们的实现，是Rod.Johnson在他的另一本著作《Expert One-on-One J2EE Development without EJB》 中，所提到Without EJB设计思想的体现；同时也深刻的体现了Spring背后的设计理念。 \n\n从更深一点的技术层面上来看，因为Spring是一个基于Java语言的应用平台，如果我们能够对Java计算模型，比如像JVM虚拟机实现技术的基本原理有一些了解，会让我们对Spring实现的理解，更加的深入，这些JVM虚拟机的特性使用，包括像反射机制，代理类，字节码技术等等。它们都是在Spring实现中，涉及到的一些Java计算环境的底层技术；尽管对应用开发人员来说，可能不会直接去涉及这些JVM虚拟机底层实现的工作，但是了解这些背景知识，或多或少，对我们了解整个Spring平台的应用背景有很大的帮助；打个比方来说，就像我们在大学中，学习的那些关于计算机组织和系统方面的基本知识，比如像数字电路，计算机组成原理，汇编语言，操作系统等等这些基本课程的学习。虽然，坦率的来说，对我们这些大多数课程的学习者，在以后的工作中，可能并没有太多的机会，直接从事这么如此底层的技术开发工作；但具备这些知识背景，为我们深入理解基于这些基础技术构架起来的应用系统，毫无疑问，是不可缺少的。随着JVM虚拟机技术的发展，可以设想到的是，更多虚拟机级别的基本特性，将会持续的被应用平台开发者所关注和采用，这也是我们在学习平台实现的过程中，非常值得注意的一点，因为这些底层技术实现，毫无疑问，会对Spring应用平台的开发路线，产品策略产生重大的影响。同时，在使用Spring作为应用平台的时候，如果需要更深层次的开发和性能调优，这些底层的知识，也是我们知识库中不可缺少的部分。有了这些底层知识，理解整个系统，想来就应该障碍不大了。 \n\n### IOC的一点认识 \n\n对Spring IOC的理解离不开对依赖反转模式的理解，我们知道，关于如何反转对依赖的控制，把控制权从具体业务对象手中转交到平台或者框架中，是解决面向对象系统设计复杂性和提高面向对象系统可测试性的一个有效的解决方案。这个问题触发了IoC设计模式的发展，是IoC容器要解决的核心问题。同时，也是产品化的IoC容器出现的推动力。而我觉得Spring的IoC容器，就是一个开源的实现依赖反转模式的产品。 \n\n那具体什么是IoC容器呢？它在Spring框架中到底长什么样？说了这么多，其实对IoC容器的使用者来说，我们常常接触到的BeanFactory和ApplicationContext都可以看成是容器的具体表现形式。这些就是IoC容器，或者说在Spring中提IoC容器，从实现来说，指的是一个容器系列。这也就是说，我们通常所说的IoC容器，如果深入到Spring的实现去看，会发现IoC容器实际上代表着一系列功能各异的容器产品。只是容器的功能有大有小，有各自的特点。打个比方来说，就像是百货商店里出售的商品，我们举水桶为例子，在商店中出售的水桶有大有小；制作材料也各不相同，有金属的，有塑料的等等，总之是各式各样，但只要能装水，具备水桶的基本特性，那就可以作为水桶来出售来让用户使用。这在Spring中也是一样，它有各式各样的IoC容器的实现供用户选择和使用；使用什么样的容器完全取决于用户的需要，但在使用之前如果能够了解容器的基本情况，那会对容器的使用是非常有帮助的；就像我们在购买商品时进行的对商品的考察和挑选那样。 \n\n我们从最基本的XmlBeanFactory看起，它是容器系列的最底层实现，这个容器的实现与我们在Spring应用中用到的那些上下文相比，有一个非常明显的特点，它只提供了最基本的IoC容器的功能。从它的名字中可以看出，这个IoC容器可以读取以XML形式定义的BeanDefinition。理解这一点有助于我们理解ApplicationContext与基本的BeanFactory之间的区别和联系。我们可以认为直接的BeanFactory实现是IoC容器的基本形式，而各种ApplicationContext的实现是IoC容器的高级表现形式。 \n\n仔细阅读XmlBeanFactory的源码，在一开始的注释里面已经对 XmlBeanFactory的功能做了简要的说明，从代码的注释还可以看到，这是Rod Johnson在2001年就写下的代码，可见这个类应该是Spring的元老类了。它是继承DefaultListableBeanFactory这个类的，这个DefaultListableBeanFactory就是一个很值得注意的容器！\n\n```java\npublic class XmlBeanFactory extends DefaultListableBeanFactory {  \n    private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);  \n    public XmlBeanFactory(Resource resource) throws BeansException {  \n        this(resource, null);  \n    }  \n    public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {  \n        super(parentBeanFactory);  \n        this.reader.loadBeanDefinitions(resource);  \n    }  \n}  \n```\n\nXmlBeanFactory的功能是建立在DefaultListableBeanFactory这个基本容器的基础上的，在这个基本容器的基础上实现了其他诸如XML读取的附加功能。对于这些功能的实现原理，看一看XmlBeanFactory的代码实现就能很容易地理解。在如下的代码中可以看到，在XmlBeanFactory构造方法中需要得到Resource对象。对XmlBeanDefinitionReader对象的初始化，以及使用这个这个对象来完成loadBeanDefinitions的调用，就是这个调用启动了从Resource中载入BeanDefinitions的过程，这个loadBeanDefinitions同时也是IoC容器初始化的重要组成部分。 \n\n简单来说，IoC容器的初始化包括BeanDefinition的Resouce定位、载入和注册这三个基本的过程。我觉得重点是在载入和对BeanDefinition做解析的这个过程。可以从DefaultListableBeanFactory来入手看看IoC容器是怎样完成BeanDefinition载入的。在refresh调用完成以后，可以看到loadDefinition的调用： \n\n```java\npublic abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {\n\tpublic AbstractXmlApplicationContext() {\n\t}\n\tpublic AbstractXmlApplicationContext(ApplicationContext parent) {\n\t\tsuper(parent);\n\t}\n\t//这里是实现loadBeanDefinitions的地方\n\tprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws IOException {\n\t\t// Create a new XmlBeanDefinitionReader for the given BeanFactory.\n\t\t// 创建 XmlBeanDefinitionReader，并通过回调设置到 BeanFactory中去，创建BeanFactory的使用的也是 DefaultListableBeanFactory。\n\t\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\n\t\t// Configure the bean definition reader with this context's\n\t\t// resource loading environment.\n\t\t// 这里设置 XmlBeanDefinitionReader， 为XmlBeanDefinitionReader 配置ResourceLoader，因为DefaultResourceLoader是父类，所以this可以直接被使用\n\t\tbeanDefinitionReader.setResourceLoader(this);\n\t\tbeanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n\t\t// Allow a subclass to provide custom initialization of the reader,\n\t\t// then proceed with actually loading the bean definitions.\n\t// 这是启动Bean定义信息载入的过程\n\t\tinitBeanDefinitionReader(beanDefinitionReader);\n\t\tloadBeanDefinitions(beanDefinitionReader);\n\t}\n\n\tprotected void initBeanDefinitionReader(XmlBeanDefinitionReader beanDefinitionReader) {\n\t}\n\n```\n\n这里使用 XmlBeanDefinitionReader来载入BeanDefinition到容器中，如以下代码清单所示： \n\n```java\n\t/**\n\t * 这里对指定bean元素的property子元素集合进行解析。\n\t */\n\tpublic void parsePropertyElements(Element beanEle, BeanDefinition bd) {\n\t\t//遍历所有bean元素下定义的property元素\n\t\tNodeList nl = beanEle.getChildNodes();\n\t\tfor (int i = 0; i \u003c nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element \u0026\u0026 DomUtils.nodeNameEquals(node, PROPERTY_ELEMENT)) {\n\t\t\t\t//在判断是property元素后对该property元素进行解析的过程\n\t\t\t\tparsePropertyElement((Element) node, bd);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void parsePropertyElement(Element ele, BeanDefinition bd) {\n\t\t//这里取得property的名字\n\t\tString propertyName = ele.getAttribute(NAME_ATTRIBUTE);\n\t\tif (!StringUtils.hasLength(propertyName)) {\n\t\t\terror(\"Tag 'property' must have a 'name' attribute\", ele);\n\t\t\treturn;\n\t\t}\n\t\tthis.parseState.push(new PropertyEntry(propertyName));\n\t\ttry {\n\t\t\t//如果同一个bean中已经有同名的存在，则不进行解析，直接返回。也就是说，如果在同一个bean中有同名的property设置，那么起作用的只是第一个。\n\t\t\tif (bd.getPropertyValues().contains(propertyName)) {\n\t\t\t\terror(\"Multiple 'property' definitions for property '\" + propertyName + \"'\", ele);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//这里是解析property值的地方，返回的对象对应对Bean定义的property属性设置的解析结果，这个解析结果会封装到PropertyValue对象中，然后设置到BeanDefinitionHolder中去。\n\t\t\tObject val = parsePropertyValue(ele, bd, propertyName);\n\t\t\tPropertyValue pv = new PropertyValue(propertyName, val);\n\t\t\tparseMetaElements(ele, pv);\n\t\t\tpv.setSource(extractSource(ele));\n\t\t\tbd.getPropertyValues().addPropertyValue(pv);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\t}\n\t/**\n\t * 这里取得property元素的值，也许是一个list或其他。\n\t */\n\tpublic Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) {\n\t\tString elementName = (propertyName != null) ?\n\t\t\t\t\t\t\"\u003cproperty\u003e element for property '\" + propertyName + \"'\" :\n\t\t\t\t\t\t\"\u003cconstructor-arg\u003e element\";\n\n\t\t// Should only have one child element: ref, value, list, etc.\n\t\tNodeList nl = ele.getChildNodes();\n\t\tElement subElement = null;\n\t\tfor (int i = 0; i \u003c nl.getLength(); i++) {\n\t\t\tNode node = nl.item(i);\n\t\t\tif (node instanceof Element \u0026\u0026 !DomUtils.nodeNameEquals(node, DESCRIPTION_ELEMENT) \u0026\u0026\n\t\t\t\t\t!DomUtils.nodeNameEquals(node, META_ELEMENT)) {\n\t\t\t\t// Child element is what we're looking for.\n\t\t\t\tif (subElement != null) {\n\t\t\t\t\terror(elementName + \" must not contain more than one sub-element\", ele);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsubElement = (Element) node;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//这里判断property的属性，是ref还是value,不允许同时是ref和value。\n\t\tboolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);\n\t\tboolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);\n\t\tif ((hasRefAttribute \u0026\u0026 hasValueAttribute) ||\n\t\t\t\t((hasRefAttribute || hasValueAttribute) \u0026\u0026 subElement != null)) {\n\t\t\terror(elementName +\n\t\t\t\t\t\" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element\", ele);\n\t\t}\n\t\t//如果是ref，创建一个ref的数据对象RuntimeBeanReference,这个对象封装了ref的信息。\n\t\tif (hasRefAttribute) {\n\t\t\tString refName = ele.getAttribute(REF_ATTRIBUTE);\n\t\t\tif (!StringUtils.hasText(refName)) {\n\t\t\t\terror(elementName + \" contains empty 'ref' attribute\", ele);\n\t\t\t}\n\t\t\tRuntimeBeanReference ref = new RuntimeBeanReference(refName);\n\t\t\tref.setSource(extractSource(ele));\n\t\t\treturn ref;\n\t\t} //如果是value，创建一个value的数据对象TypedStringValue ,这个对象封装了value的信息。\n\t\telse if (hasValueAttribute) {\n\t\t\tTypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));\n\t\t\tvalueHolder.setSource(extractSource(ele));\n\t\t\treturn valueHolder;\n\t\t} //如果还有子元素，触发对子元素的解析\n\t\telse if (subElement != null) {\n\t\t\treturn parsePropertySubElement(subElement, bd);\n\t\t}\n\t\telse {\n\t\t\t// Neither child element nor \"ref\" or \"value\" attribute found.\n\t\t\terror(elementName + \" must specify a ref or value\", ele);\n\t\t\treturn null;\n\t\t}\n\t}\n```\n\n关于具体的Spring BeanDefinition的解析，是在BeanDefinitionParserDelegate中完成的。这个类里包含了各种Spring Bean定义规则的处理，感兴趣的同学可以仔细研究。我们举一个例子来分析这个处理过程，比如我们最熟悉的对Bean元素的处理是怎样完成的，也就是我们在XML定义文件中出现的\u003cbean\u003e\u003c/bean\u003e这个最常见的元素信息是怎样被处理的。在这里，我们会看到那些熟悉的BeanDefinition定义的处理，比如id、name、aliase等属性元素。把这些元素的值从XML文件相应的元素的属性中读取出来以后，会被设置到生成的BeanDefinitionHolder中去。这些属性的解析还是比较简单的。对于其他元素配置的解析，比如各种Bean的属性配置，通过一个较为复杂的解析过程，这个过程是由parseBeanDefinitionElement来完成的。解析完成以后，会把解析结果放到BeanDefinition对象中并设置到BeanDefinitionHolder中去，如以下清单所示：\n\n```java\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {\n\t\t//这里取得在\u003cbean\u003e元素中定义的id、name和aliase属性的值\n\t\tString id = ele.getAttribute(ID_ATTRIBUTE);\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n\t\tList\u003cString\u003e aliases = new ArrayList\u003cString\u003e();\n\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\tString[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS);\n\t\t\taliases.addAll(Arrays.asList(nameArr));\n\t\t}\n\n\t\tString beanName = id;\n\t\tif (!StringUtils.hasText(beanName) \u0026\u0026 !aliases.isEmpty()) {\n\t\t\tbeanName = aliases.remove(0);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No XML 'id' specified - using '\" + beanName +\n\t\t\t\t\t\t\"' as bean name and \" + aliases + \" as aliases\");\n\t\t\t}\n\t\t}\n\n\t\tif (containingBean == null) {\n\t\t\tcheckNameUniqueness(beanName, aliases, ele);\n\t\t}\n\n\t\t//这个方法会引发对bean元素的详细解析\nAbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n\t\tif (beanDefinition != null) {\n\t\t\tif (!StringUtils.hasText(beanName)) {\n\t\t\t\ttry {\n\t\t\t\t\tif (containingBean != null) {\n\t\t\t\t\t\tbeanName = BeanDefinitionReaderUtils.generateBeanName(\n\t\t\t\t\t\t\t\tbeanDefinition, this.readerContext.getRegistry(), true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbeanName = this.readerContext.generateBeanName(beanDefinition);\n\t\t\t\t\t\t// Register an alias for the plain bean class name, if still possible,\n\t\t\t\t\t\t// if the generator returned the class name plus a suffix.\n\t\t\t\t\t\t// This is expected for Spring 1.2/2.0 backwards compatibility.\n\t\t\t\t\t\tString beanClassName = beanDefinition.getBeanClassName();\n\t\t\t\t\t\tif (beanClassName != null \u0026\u0026\n\t\t\t\t\t\t\t\tbeanName.startsWith(beanClassName) \u0026\u0026 beanName.length() \u003e beanClassName.length() \u0026\u0026\n\t\t\t\t\t\t\t\t!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n\t\t\t\t\t\t\taliases.add(beanClassName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Neither XML 'id' nor 'name' specified - \" +\n\t\t\t\t\t\t\t\t\"using generated bean name [\" + beanName + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\terror(ex.getMessage(), ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] aliasesArray = StringUtils.toStringArray(aliases);\n\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n\t\t}\n\n\t\treturn null;\n\t}\n```\n\n比如，再往下看，我们看到像List这样的属性配置是怎样被解析的，依然在BeanDefinitionParserDelegate中：返回的是一个List对象，这个List是Spring定义的ManagedList，作为封装List这类配置定义的数据封装，如以下代码清单所示。 \n\n```java\n\tpublic List parseListElement(Element collectionEle, BeanDefinition bd) {\n\t\tString defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);\n\t\tNodeList nl = collectionEle.getChildNodes();\n\t\tManagedList\u003cObject\u003e target = new ManagedList\u003cObject\u003e(nl.getLength());\n\t\ttarget.setSource(extractSource(collectionEle));\n\t\ttarget.setElementTypeName(defaultElementType);\n\t\ttarget.setMergeEnabled(parseMergeAttribute(collectionEle));\n\t\t//具体的List元素的解析过程。\n\t\tparseCollectionElements(nl, target, bd, defaultElementType);\n\t\treturn target;\n\t}\n\tprotected void parseCollectionElements(\n\t\t\tNodeList elementNodes, Collection\u003cObject\u003e target, BeanDefinition bd, String defaultElementType) {\n\t\t//遍历所有的元素节点，并判断其类型是否为Element。\n\t\tfor (int i = 0; i \u003c elementNodes.getLength(); i++) {\n\t\t\tNode node = elementNodes.item(i);\n\t\t\tif (node instanceof Element \u0026\u0026 !DomUtils.nodeNameEquals(node, DESCRIPTION_ELEMENT)) {\n\t\t//加入到target中去，target是一个ManagedList，同时触发对下一层子元素的解析过程，这是一个递归的调用。\n\t\t\t\ttarget.add(parsePropertySubElement((Element) node, bd, defaultElementType));\n\t\t\t}\n\t\t}\n\t}\n```\n\n经过这样一层一层的解析，我们在XML文件中定义的BeanDefinition就被整个给载入到了IoC容器中，并在容器中建立了数据映射。在IoC容器中建立了对应的数据结构，或者说可以看成是POJO对象在IoC容器中的映像，这些数据结构可以以AbstractBeanDefinition为入口，让IoC容器执行索引、查询和操作。 \n\n在我的感觉中，对核心数据结构的定义和处理应该可以看成是一个软件的核心部分了。所以，这里的BeanDefinition的载入可以说是IoC容器的核心，如果说IoC容器是Spring的核心，那么这些BeanDefinition就是Spring的核心的核心了！ \n\n呵呵，这部分代码数量不小，但如果掌握这条主线，其他都可以举一反三吧，就像我们掌握了操作系统启动的过程，以及在操作系统设计中的核心数据结构像进程数据结构，文件系统数据结构，网络协议数据结构的设计和处理一样，对整个系统的设计原理，包括移植，驱动开发和应用开发，是非常有帮助的！ ","cover":"/images/example.png","link":"ink-blog-spring1.html","preview":"\u003cp\u003e下面我们从IOC/AOP开始，它们是Spring平台实现的核心部分；虽然，我们一开始大多只是在这个层面上，做一些配置和外部特性的使用工作，但对这两个核心模块工作原理和运作机制的理解，对深入理解Spring平台，却是至关重要的。\u003c/p\u003e\n","title":"Spring技术内幕——深入解析Spring架构与设计原理（一）IOC实现原理"}]